package com.lucanicoletti.ComposeMapsTutorial


import com.google.android.gms.maps.model.Tile
import com.google.android.gms.maps.model.TileProvider
import com.jakewharton.disklrucache.DiskLruCache
import java.io.ByteArrayOutputStream
import java.io.DataInputStream
import java.io.DataOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

/**
 * Wrapper that provides a disk-based LRU cache for a TileProvider.
 *
 * @see com.jakewharton.disklrucache.DiskLruCache
 */
class CachedTileProvider(
    private val mKeyTag: String,
    private val mTileProvider: TileProvider,
    cache: DiskLruCache
) :
    TileProvider {
    private val mCache: DiskLruCache = cache

    /**
     * Load a tile.
     * If cached, the data for the tile is read from the underlying cache, otherwise the tile is
     * generated by the [com.google.android.gms.maps.model.TileProvider] and added to the
     * cache.
     *
     * @param x
     * @param y
     * @param zoom
     * @return
     */
    override fun getTile(x: Int, y: Int, zoom: Int): Tile? {
        val key = generateKey(x, y, zoom, mKeyTag)
        var tile = getCachedTile(key)
        if (tile == null) {
            // tile not cached, load from provider and then cache
            tile = mTileProvider.getTile(x, y, zoom)
        }
        return tile
    }

    /**
     * Load a tile from cache.
     * Returns null if there is no corresponding cache entry or it could not be loaded.
     *
     * @param key
     * @return
     */
    private fun getCachedTile(key: String): Tile? {
        try {
            val snapshot: DiskLruCache.Snapshot = mCache.get(key) ?: return null
            val data = readStreamAsByteArray(snapshot.getInputStream(INDEX_DATA))
            val height = readStreamAsInt(snapshot.getInputStream(INDEX_HEIGHT))
            val width = readStreamAsInt(snapshot.getInputStream(INDEX_WIDTH))
            return Tile(width, height, data)
        } catch (e: IOException) {
            // ignore error
        }
        return null
    }

    private fun cacheTile(key: String, tile: Tile?): Boolean {
        try {
            val editor: DiskLruCache.Editor = mCache.edit(key)
                ?: // editor is not available
                return false
            writeByteArrayToStream(tile!!.data, editor.newOutputStream(INDEX_DATA))
            writeIntToStream(tile.height, editor.newOutputStream(INDEX_HEIGHT))
            writeIntToStream(tile.width, editor.newOutputStream(INDEX_WIDTH))
            editor.commit()
            return true
        } catch (e: IOException) {
            // Tile could not be cached
        }
        return false
    }

    companion object {
        private const val KEY_FORMAT = "%d_%d_%d_%s"

        // Index for cache entry streams
        private const val INDEX_DATA = 0
        private const val INDEX_HEIGHT = 1
        private const val INDEX_WIDTH = 2
        private fun generateKey(x: Int, y: Int, zoom: Int, tag: String): String {
            return String.format(java.util.Locale.getDefault(), KEY_FORMAT, x, y, zoom, tag)
        }

        @Throws(IOException::class)
        private fun writeByteArrayToStream(data: ByteArray?, stream: OutputStream) {
            stream.use { stream ->
                stream.write(data)
            }
        }

        @Throws(IOException::class)
        private fun writeIntToStream(data: Int, stream: OutputStream) {
            val dos = DataOutputStream(stream)
            try {
                dos.writeInt(data)
            } finally {
                stream.use { _ ->
                    dos.close()
                }
            }
        }

        @Throws(IOException::class)
        private fun readStreamAsByteArray(inputStream: InputStream): ByteArray {
            val buffer = ByteArrayOutputStream()
            var read: Int
            val data = ByteArray(1024)
            inputStream.use { inStream ->
                while ((inStream.read(data, 0, data.size).also { read = it }) != -1) {
                    buffer.write(data, 0, read)
                }
            }
            return buffer.toByteArray()
        }

        @Throws(IOException::class)
        private fun readStreamAsInt(inputStream: InputStream): Int {
            val buffer = DataInputStream(inputStream)
            inputStream.use { _ ->
                return buffer.readInt()
            }
        }
    }
}